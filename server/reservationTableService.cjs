const { Pool } = require('pg');

// Utilise la m√™me configuration que les autres services
let pool;

const initPool = (poolInstance) => {
  pool = poolInstance;
};

// Service pour g√©rer la table des r√©servations
class ReservationTableService {
  
  static async createTable() {
    const client = await pool.connect();
    try {
      console.log('üîÑ V√©rification/cr√©ation de la table reservations...');
      
      await client.query('BEGIN');

      // Cr√©er la table principale
      await client.query(`
        CREATE TABLE IF NOT EXISTS reservations (
          id SERIAL PRIMARY KEY,
          prenom VARCHAR(100) NOT NULL,
          nom VARCHAR(100) NOT NULL,
          email VARCHAR(255) NOT NULL,
          telephone VARCHAR(20) NOT NULL,
          adresse TEXT NOT NULL,
          type_voiture VARCHAR(50) NOT NULL,
          marque_voiture VARCHAR(100) NOT NULL,
          formule VARCHAR(255) NOT NULL,
          prix DECIMAL(10,2),
          date_rdv DATE NOT NULL,
          heure_rdv TIME NOT NULL,
          commentaires TEXT,
          newsletter BOOLEAN DEFAULT false,
          status VARCHAR(20) DEFAULT 'pending',
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
      `);

      // Cr√©er les index pour am√©liorer les performances (en une seule fois)
      await client.query(`
        DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_reservations_date_rdv') THEN
            CREATE INDEX idx_reservations_date_rdv ON reservations(date_rdv);
          END IF;
          
          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_reservations_status') THEN
            CREATE INDEX idx_reservations_status ON reservations(status);
          END IF;
          
          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_reservations_email') THEN
            CREATE INDEX idx_reservations_email ON reservations(email);
          END IF;
          
          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_reservations_type_voiture') THEN
            CREATE INDEX idx_reservations_type_voiture ON reservations(type_voiture);
          END IF;
        END
        $$;
      `);

      // Ajouter une contrainte pour v√©rifier le statut (si elle n'existe pas d√©j√†)
      await client.query(`
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM information_schema.table_constraints 
            WHERE constraint_name = 'check_status' 
            AND table_name = 'reservations'
          ) THEN
            ALTER TABLE reservations 
            ADD CONSTRAINT check_status 
            CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));
          END IF;
        END
        $$;
      `);

      await client.query('COMMIT');
      console.log('‚úÖ Table reservations cr√©√©e/v√©rifi√©e avec succ√®s');
      return { success: true };

    } catch (error) {
      await client.query('ROLLBACK');
      console.error('‚ùå Erreur lors de la cr√©ation de la table reservations:', error.message);
      throw error;
    } finally {
      client.release();
    }
  }

  // V√©rifier si la table existe
  static async tableExists() {
    try {
      const result = await pool.query(`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'reservations'
        );
      `);
      return result.rows[0].exists;
    } catch (error) {
      console.error('Erreur v√©rification table reservations:', error);
      return false;
    }
  }

  // Obtenir des statistiques sur la table
  static async getTableStats() {
    try {
      const exists = await this.tableExists();
      if (!exists) {
        return { exists: false };
      }

      const countResult = await pool.query('SELECT COUNT(*) as count FROM reservations');
      const statusResult = await pool.query(`
        SELECT status, COUNT(*) as count 
        FROM reservations 
        GROUP BY status 
        ORDER BY status
      `);

      return {
        exists: true,
        totalReservations: parseInt(countResult.rows[0].count),
        statusBreakdown: statusResult.rows
      };
    } catch (error) {
      console.error('Erreur statistiques table reservations:', error);
      return { exists: false, error: error.message };
    }
  }
}

module.exports = {
  ReservationTableService,
  initPool
}; 